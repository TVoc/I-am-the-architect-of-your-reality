\documentclass[a4paper,10pt]{article}

\usepackage[english]{babel}
\usepackage{graphicx}
\graphicspath{{./figures/}}
\usepackage[colorlinks, linkcolor=black, citecolor=black, urlcolor=black]{hyperref}
\usepackage{geometry}
\geometry{tmargin=3cm, bmargin=2.2cm, lmargin=2.2cm, rmargin=2cm}
\usepackage{todonotes} %Used for the figure placeholders

\begin{document}
\input{titlepage}

\tableofcontents
\newpage

\section{Introduction}\label{sec:introduction}

\section{Attribute-driven design documentation}\label{sec:add}
\subsection{Decomposition 1: eDocs System (Av1, P1, UC4, UC5)}
\subsubsection{Module to decompose}
In this (first) run we decompose \texttt{the eDocs System}.

\subsubsection{Selected architectural drivers}
The non-functional drivers for this decomposition are:

\begin{itemize}
    \item \emph{Av1}: Document Generation Failure
    \item \emph{P1}: Document Generation
\end{itemize}

The related functional drivers are:

\begin{itemize}
    \item \emph{UC4}: Generate Payslip
    \item \emph{UC5}: Generate Invoice
\end{itemize}

\paragraph{Rationale}
Both of these non-functional drivers and both use-cases handle the generation of documents by the system. This is one of two core functionalities of the system as a whole, the other being the delivery of said documents. Because they are so important (as also implied by their high priority), makes them both an excellent and cohesive group of drivers for the first run.

\subsubsection{Architectural design}
\paragraph{Raw data queueing for \emph{P1}}
\emph{P1} describes the generation of documents out of raw data. This raw data comes generally comes from a submission subsystem to the generation subsystem. Requiring the generation subsystem to immediately process all received raw data makes for a very strict implementation and possible dropped data when under sudden unforseen load. Due to this, we chose to introduce a component, the \texttt{Raw Data Pool}, which receives the submitted raw data to be processed. The generation subsystem will select raw data out of this pool and mark it as being processed. After a document is generated, the pool is notified that the raw data should be removed. The \texttt{Raw Data Pool} accepts a scheduling strategy. This strategy allows the pool to sort its contents in a way that is useful for the generation system to more easily find the document to be generated next. The \texttt{Raw Data Pool} is dynamically resizable to store all received raw data entries at any given time. The \texttt{Scheduling Module} (see paragraph ``Recurring load scheduling for P1'') notifies the pool when a large(r) batch of raw data is due, so the pool can expand to accomodate this load. The System will try to keep this pool filled at most half-way, while keeping the parallel document generation jobs to a minimum. \todo{Pattern or tactic for this behaviour?} When the pool reaches half capacity, the System will instantiate more parallel generation jobs to keep the pool from reaching full capacity. When this measure is ineffective, the pool will expand further as necessary to ensure full capacity is never reached.

\paragraph{Recurring load scheduling for \emph{P1}}
According to \emph{P1}, the System should anticipate when recurring batches of data are received. For this purpose, a \texttt{Scheduling Module} is introduced. This module knows when a recurring batch is scheduled to be received. It will signal the system how many parallel Document Generation jobs and how much \texttt{Raw Data Pool} capacity should be present, when a recurring batch will be received shortly. This knowledge is introduced/added to the module when a (new) SLA is signed.

\paragraph{Dynamic load anticipation for \emph{P1}}
Discussion of the solution selected for (a part of) one of the architectural
drivers.

\paragraph{Failure Detection for \emph{Av1}}
The System should be able to detect when the Document Generation \todo{rename ``subsystem''?} subsystem fails. 


\paragraph{Topic}
Discussion of the solution selected for (a part of) one of the architectural
drivers.

\paragraph{Topic}
Discussion of the solution selected for (a part of) one of the architectural
drivers.

\subsubsection*{Alternatives considered}
\paragraph{Alternatives for solution}
A discussion of the alternative solutions and why that were not selected.

\subsubsection{Instantiation and allocation of functionality}
\paragraph{Decomposition}
Main aspects of the resulting decomposition.

\subparagraph{ModuleB}
Per introduced component a paragraph describing its responsibilities.

\subparagraph{ModuleC}
Per introduced component a paragraph describing its responsibilities.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Component-and-connector diagram}
    \caption{Component-and-connector diagram of this decomposition.
        }\label{fig:it1-cc_main}
\end{figure}

\paragraph{Behaviour}
If needed and explanation of the behaviour of certain aspects of the design so
far.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Sequence diagram}
    \caption{Sequence diagram illustrating a key behavioural aspect.
        }\label{fig:it1-seq_aspect1}
\end{figure}

\paragraph{Deployment}
Rationale of the allocation of components to physical nodes.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Deployment diagram}
    \caption{Deployment diagram of this decomposition.
        }\label{fig:it1-depl_main}
\end{figure}

\subsubsection{Interfaces for child modules}
\subsubsection*{ModuleB}
\begin{itemize}
    \item InterfaceA
    \begin{itemize}
        \item \texttt{returnType operation1(ParamType param1)} throws TypeOfException
        \begin{itemize}
            \item Effect: Describe the effect of calling this operation.
            \item Exceptions: 
            \begin{itemize}
                \item TypeOfException: Describe when this exception is thrown.
            \end{itemize}
        \end{itemize}

        \item \texttt{returnType operation2()}
        \begin{itemize}
            \item Effect: Describe the effect of calling this operation.
            \item Exceptions: None
         \end{itemize}
    \end{itemize}
\end{itemize}

\subsubsection{Data type definitions}
Describe per complex data type used in the interfaces what it represents.

\paragraph{returnType} This data element represents X.

\paragraph{ParamType} This data element represents Y.

\subsubsection{Verify and refine}
This section describes per component which (parts of) the remaining
requirements it is responsible for.

\paragraph{ModuleB}
\begin{itemize}
    \item \emph{Z1}: name
    \item \emph{UCd}: name
\end{itemize}

\paragraph{ModuleC}
\begin{itemize}
    \item \emph{UCba}: name\\Description which part of the original use case is
        the responsibility of this component.
\end{itemize}

\subsection{Decomposition 2: Module (drivers)}
\subsubsection{Module to decompose}
\subsubsection{Selected architectural drivers}
\subsubsection{Architectural design}
\subsubsection{Instantiation and allocation of functionality}
\subsubsection{Interfaces for child modules}
\subsubsection{Data type definitions}
\subsubsection{Verify and refine}

\subsection{Decomposition 3: Module (drivers)}
\subsubsection{Module to decompose}
\subsubsection{Selected architectural drivers}
\subsubsection{Architectural design}
\subsubsection{Instantiation and allocation of functionality}
\subsubsection{Interfaces for child modules}
\subsubsection{Data type definitions}
\subsubsection{Verify and refine}

\section{Resulting partial architecture}\label{sec:architecture}
This section provides an over of the architecture constructed through ADD\@.

\subsection{Context diagram}
This subsection discusses the context diagram.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Context diagram for component-and-
        connector view.}
    \caption{Context diagram for the component-and-connector view.
        }\label{fig:cc_context}
\end{figure}

\subsection{Component-and-connector view}
A short discussion of the component-and-connector view with the key
decompositions if any.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Component-and-connector diagram}
    \caption{Primary diagram for the component-and-connector view.
        }\label{fig:cc_main}
\end{figure}

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Key decomposition}
    \caption{Decomposition of a component shown in Figure~\ref{fig:cc_main}
        }\label{fig:decomp_decomp1}
\end{figure}

\subsection{Deployment view}
A short discussion of the allocation of components to physical nodes based on a
context diagram and a deployment diagram.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Context diagram for the allocation
        view.}
    \caption{Context diagram for the allocation view.}\label{fig:depl_context}
\end{figure}

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Deployment diagram}
    \caption{Primary diagram for the allocation view.}\label{fig:depl_main}
\end{figure}

\end{document}
