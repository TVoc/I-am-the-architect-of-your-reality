\documentclass[a4paper,10pt]{article}

\usepackage[english]{babel}
\usepackage{graphicx}
\graphicspath{{./figures/}}
\usepackage[colorlinks, linkcolor=black, citecolor=black, urlcolor=black]{hyperref}
\usepackage{geometry}
\geometry{tmargin=3cm, bmargin=2.2cm, lmargin=2.2cm, rmargin=2cm}
\usepackage{todonotes} %Used for the figure placeholders

\begin{document}
\input{titlepage}

\tableofcontents
\newpage

\section{Introduction}\label{sec:introduction}

\section{Attribute-driven design documentation}\label{sec:add}
\subsection{Decomposition 1: eDocs System (Av1, P1, UC4, UC5)}
\subsubsection{Module to decompose}
In this (first) run we decompose \texttt{the eDocs System}.

\subsubsection{Selected architectural drivers}
The non-functional drivers for this decomposition are:

\begin{itemize}
    \item \emph{Av1}: Document Generation Failure
    \item \emph{P1}: Document Generation
\end{itemize}

The related functional drivers are:

\begin{itemize}
    \item \emph{UC4}: Generate Payslip
    \item \emph{UC5}: Generate Invoice
\end{itemize}

\paragraph{Rationale}
Both of these non-functional drivers and both use-cases handle the generation of documents by the system. This is one of two core functionalities of the system as a whole, the other being the delivery of said documents. Because they are so important (as also implied by their high priority), makes them both an excellent and cohesive group of drivers for the first run.

\subsubsection{Architectural design}
\paragraph{Raw data queueing for \emph{P1}}
\emph{P1} describes the generation of documents out of raw data. This raw data comes generally comes from a submission subsystem to the generation subsystem. Requiring the generation subsystem to immediately process all received raw data makes for a very strict implementation and possible dropped data when under sudden unforseen load. Due to this, we chose to introduce a component, the \texttt{Raw Data Pool}, which receives the submitted raw data to be processed. The generation subsystem will select raw data out of this pool and mark it as being processed. After a document is generated, the pool is notified that the raw data should be removed. The \texttt{Raw Data Pool} knows of the desired priority scheduling strategy. This strategy allows the pool to sort its contents such that it can always provide the next Raw Data Entry to be generated according to the priority scheduling strategy. The \texttt{Raw Data Pool} is dynamically resizable to store all received raw data entries at any given time. The \texttt{Scheduler Module} (see paragraph ``Recurring load scheduling for P1'') notifies the pool when a large(r) batch of raw data is due, so the pool can expand to accomodate this load. To counter unforseen load, the pool will try to stay under or at half capacity. \todo{Pattern or tactic for this behaviour?} When the pool reaches half capacity, it will signal the document generation subsystem that more parallel generation jobs are necessary to keep the pool from reaching full capacity. When this measure is ineffective, and the pool reaches 75 percent capacity (hereafter called ``critical capacity''), the pool will expand further as necessary to ensure full capacity is never reached. This extra storage can be present on secondary machines, or attained over the network. Whichever solution is the best/cheapest for the eDocs company.

\paragraph{Recurring load scheduling for \emph{P1}}
According to \emph{P1}, the System should anticipate when recurring batches of data are received. For this purpose, a \texttt{Scheduler Module} is introduced. This module knows when a recurring batch is scheduled to be received. It will signal the document generation subsystem and \texttt{Raw Data Pool} how many parallel Document Generation jobs and how much \texttt{Raw Data Pool} capacity should be present respectively, when a recurring batch will be received shortly. This knowledge is introduced/added to the module when a (new) SLA is signed.

\paragraph{Dynamic load anticipation for \emph{P1}}
Apart from recurring batches, the system should provide enough resources (\texttt{Raw Data Pool} capacity and parallel Document Generation jobs) for document generation of non-recurring batches. To regulate the amount of resources available in between recurring batches, a \texttt{Statistics Module} is introduced in the system. This module records the mean amount of processed documents for given time intervals, and supplies the document generation subsystem and \texttt{Raw Data Pool} with an estimate of how many document generation resources will be necessary in between recurring batches.

\paragraph{Document Generation Subsystem Structure}
In principle, the Raw Data Pool subcontracts the generation of Documents to several \texttt{Document Generator Processes}. In order to manage the complexity and scalability of this, we propose a \texttt{Raw Data Dispatcher Module}. This module is responsible for knowing which \texttt{Document Generator Processes} are active/instantiated and which Raw Data Entries have been assigned to which \texttt{Processes}. It also records at which time it assigned a specific Entry to which \texttt{Process}. The Raw Data Entry flow is as follows: a \texttt{Document Generator Process} has finished generating a Document according to its assigned Raw Data Entry. The \texttt{Dispatcher Module} temporarily stores the generated Document. The \texttt{Process} simultaneously submits the finished Document to the \texttt{Raw Data Dispatcher Module} and requests a new Raw Data Entry. The \texttt{Dispatcher Module} submits the finished document to the Document Delivery Subsystem and, when acknowledged, signals the \texttt{Raw Data Pool} that the corresponding Raw Data Entry has been successfully processed and requests the next Raw Data Entry that must be processed. It also deletes the temporarily stores generated Document upon acknowledgement. Upon receipt of the next Raw Data Entry, the \texttt{Dispatcher Module} gives the Entry to the \texttt{Document Generator Process} that initiated the flow and then records the following: the time at which the Entry was assigned, the responsible \texttt{Process} and a reference to the assigned Raw Data Entry. There is also a spare \texttt{Raw Data Dispatcher Module}. This is necessary in case the \texttt{Dispatcher Module} fails (see paragraph ``Raw Data Dispatcher Module Failure Detection and Resolution for \emph{Av1}''). Whenever the active \texttt{Dispatcher Module} records a new Raw Data assignment, it also signals the spare \texttt{Dispatcher Module} to record that assignment as well. The spare \texttt{Dispatcher Module} is aware of the \texttt{Raw Data Pool} and kept up to date on all currently active/instantiated \texttt{Document Generator Processes}. This is done in order to enable the spare \texttt{Dispatcher Module} to assume the responsibilities of the active \texttt{Dispatcher Module} as seamlessly as possible.

\paragraph{Document Generator Process Failure Detection and Resolution for \emph{Av1}}
An individual \texttt{Document Generator Process} may fail. There are two situations in which this may happen: the first (and rather trivial) is when a \texttt{Process} has finished generating a Document and has requested a new Raw Data Entry. When the \texttt{Dispatcher Module} offers a new Raw Data Entry, it is able to detect failure when the \texttt{Process} does not respond. The \texttt{Process} should then be terminated and a new \texttt{Process} instantiated that subsequently starts work on the previously offered Raw Data Entry. The second (and more interesting) case is when a \texttt{Process} fails while generating a Document. In order to counteract Raw Data loss, there is a leasing system in place. The \texttt{Raw Data Dispatcher Module} knows which Raw Data Entries have been assigned to which \texttt{Document Generator Processes}, and each \texttt{Process} has a set lease time during which it should submit the generated Document or renew its lease. A \texttt{Process} may only renew its lease a set amount of times to prevent it from holding on to a Raw Data Entry indefinitely. When a lease has expired, the \texttt{Dispatcher Module} pings the offending \texttt{Process}. If it does not respond with an echo, the \texttt{Process} is marked as failed. If it does respond, the lease is implicitly renewed except if the \texttt{Process} has already reached the maximum amount of lease renewals, in which case it is also marked as failed. As in the first case, when a \texttt{Process} is terminated, a new \texttt{Process} is instantiated and the Raw Data Entry that was previously assigned to the failed \texttt{Process} is then offered to the new \texttt{Process}. 

\paragraph{Raw Data Dispatcher Module Failure Detection and Resolution for \emph{Av1}}
The \texttt{Raw Data Dispatcher Module} may fail. As it is a single point of failure, this issue deserves due consideration. In order to detect failure, there is a \texttt{Dispatcher Supervisor Module}. This module supervises the \texttt{Raw Data Dispatcher Module} by means of a heartbeat. Each time the \texttt{Dispatcher Module} submits a Document to the Document Delivery Subsystem, it also notifies the \texttt{Supervisor}. If there are no Raw Data Entries currently being monitored by the \texttt{Dispatcher Module}, it sends out a notification to the \texttt{Supervisor} at regular intervals that it is still alive, regardless. If the \texttt{Supervisor} has not received a notification from the \texttt{Dispatcher Module} for a set amount of time, it marks the \texttt{Dispatcher Module} as failed. 
As previously mentioned, there is a spare in place that knows which Raw Data Entries have been assigned to which \texttt{Document Generator Processes}. It knows about the \texttt{Raw Data Pool}, the currently active \texttt{Document Generator Processes} and the \texttt{Dispatcher Supervisor Module}. Also, it temporarily stores generated Documents that have yet to be submitted to the Delivery Subsystem and removes those Documents when the currently active \texttt{Dispatcher Module} confirms it has been submitted. When the \texttt{Supervisor} has determined that the currently active \texttt{Dispatcher Module} has failed and has ascertained that the failed \texttt{Dispatcher Module} has terminated, it notifies the spare that it is to assume the responsibilies of newly active \texttt{Dispatcher Module}. The newly active \texttt{Dispatcher Module} then checks the validity of its internal data by contacting the \texttt{Raw Data Pool} and all \texttt{Processes}, in order to ascertain that no events have taken place for the duration of its activation. Also, the newly active \texttt{Dispatcher Module} queries the Delivery Subsystem whether it has already delivered the generated Documents in temporary storage in order to prevent duplicate submissions of generated Documents, removing those that have indeed already been submitted (it is assumed that each Document has a unique identifier). After activation of the now active spare has been completed, the \texttt{Dispatcher Supervisor Module} instantiates a new spare \texttt{Dispatcher Module} and connects it to the currently active \texttt{Dispatcher Module}. The currently active \texttt{Dispatcher Module} then connects the spare to the \texttt{Raw Data Pool} and all currently active \texttt{Document Generator Processes}. Work can then be resumed.
The \texttt{Dispatcher Module} expects an acknowledgement each time it updates the state of the spare. In case there is no acknowledgement, the \texttt{Dispatcher Module} pings the spare. If the spare does not echo in time, it is marked as failed. The \texttt{Dispatcher Module} asks the \texttt{Dispatcher Supervisor Module} for a new spare and shares its state with the new spare. When this is done, work is resumed.

\paragraph{Topic}
Discussion of the solution selected for (a part of) one of the architectural
drivers.

\subsubsection*{Alternatives considered}
\paragraph{Dispatcher Supervisor Module also listening to Document Generator Processes}
It is reasonable to reuse the \texttt{Supervisor} to also listen for the heartbeat of the \texttt{Document Generator Processes}, since this is already its responsibility with regards to the \texttt{Dispatcher Module}. However, this solution would scale poorly and, in addition, the \texttt{Dispatcher Module} has information such that it can more adequately judge whether a certain \texttt{Document Generator Process} has failed.

\paragraph{Dedicated priority scheduling module}
Instead of handing the responsibility of priority scheduling to the \texttt{Raw Data Pool}, it is possible to have another module do this instead. However, it is faster and easier to do this in the \texttt{Raw Data Pool}. Additionally, we do not judge this to lessen the \texttt{Raw Data Pool}'s cohesion and understandability since there are many data structures that also impose an order on the items they store. 

\paragraph{Whether or not to have a \texttt{Raw Data Dispatcher} spare}
In principle, instantiating a new \texttt{Raw Data Dispatcher} and bringing it up to speed can happen quickly by aggregating information from the \texttt{Raw Data Pool}, the currently active \texttt{Document Generator Processes} and the Delivery Subsystem. However, we decided to have a spare as generating documents is one of the core aspects of the system. For this reason, recovering from failure in a timely manner is crucial.

\subsubsection{Instantiation and allocation of functionality}
\paragraph{Decomposition}
Main aspects of the resulting decomposition.

\subparagraph{ModuleB}
Per introduced component a paragraph describing its responsibilities.

\subparagraph{ModuleC}
Per introduced component a paragraph describing its responsibilities.

\begin{figure}[!htp]
    \centering
    \includegraphics[width=0.8\textwidth]{comp_diag_1.png}
    %\missingfigure[figwidth=0.8\textwidth]{Component-and-connector diagram}
    \caption{Component-and-connector diagram of this decomposition.
        }\label{fig:it1-cc_main}
\end{figure}

\paragraph{Behaviour}
If needed and explanation of the behaviour of certain aspects of the design so
far.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Sequence diagram}
    \caption{Sequence diagram illustrating a key behavioural aspect.
        }\label{fig:it1-seq_aspect1}
\end{figure}

\paragraph{Deployment}
Rationale of the allocation of components to physical nodes.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Deployment diagram}
    \caption{Deployment diagram of this decomposition.
        }\label{fig:it1-depl_main}
\end{figure}

\subsubsection{Interfaces for child modules}
\subsubsection*{ModuleB}
\begin{itemize}
    \item InterfaceA
    \begin{itemize}
        \item \texttt{returnType operation1(ParamType param1)} throws TypeOfException
        \begin{itemize}
            \item Effect: Describe the effect of calling this operation.
            \item Exceptions:
            \begin{itemize}
                \item TypeOfException: Describe when this exception is thrown.
            \end{itemize}
        \end{itemize}

        \item \texttt{returnType operation2()}
        \begin{itemize}
            \item Effect: Describe the effect of calling this operation.
            \item Exceptions: None
         \end{itemize}
    \end{itemize}
\end{itemize}

\subsubsection{Data type definitions}
Describe per complex data type used in the interfaces what it represents.

\paragraph{returnType} This data element represents X.

\paragraph{ParamType} This data element represents Y.

\subsubsection{Verify and refine}
This section describes per component which (parts of) the remaining
requirements it is responsible for.

\paragraph{ModuleB}
\begin{itemize}
    \item \emph{Z1}: name
    \item \emph{UCd}: name
\end{itemize}

\paragraph{ModuleC}
\begin{itemize}
    \item \emph{UCba}: name\\Description which part of the original use case is
        the responsibility of this component.
\end{itemize}

\subsection{Decomposition 2: Module (drivers)}
\subsubsection{Module to decompose}
\subsubsection{Selected architectural drivers}
\subsubsection{Architectural design}
\subsubsection{Instantiation and allocation of functionality}
\subsubsection{Interfaces for child modules}
\subsubsection{Data type definitions}
\subsubsection{Verify and refine}

\subsection{Decomposition 3: Module (drivers)}
\subsubsection{Module to decompose}
\subsubsection{Selected architectural drivers}
\subsubsection{Architectural design}
\subsubsection{Instantiation and allocation of functionality}
\subsubsection{Interfaces for child modules}
\subsubsection{Data type definitions}
\subsubsection{Verify and refine}

\section{Resulting partial architecture}\label{sec:architecture}
This section provides an over of the architecture constructed through ADD\@.

\subsection{Context diagram}
This subsection discusses the context diagram.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Context diagram for component-and-
        connector view.}
    \caption{Context diagram for the component-and-connector view.
        }\label{fig:cc_context}
\end{figure}

\subsection{Component-and-connector view}
A short discussion of the component-and-connector view with the key
decompositions if any.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Component-and-connector diagram}
    \caption{Primary diagram for the component-and-connector view.
        }\label{fig:cc_main}
\end{figure}

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Key decomposition}
    \caption{Decomposition of a component shown in Figure~\ref{fig:cc_main}
        }\label{fig:decomp_decomp1}
\end{figure}

\subsection{Deployment view}
A short discussion of the allocation of components to physical nodes based on a
context diagram and a deployment diagram.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Context diagram for the allocation
        view.}
    \caption{Context diagram for the allocation view.}\label{fig:depl_context}
\end{figure}

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Deployment diagram}
    \caption{Primary diagram for the allocation view.}\label{fig:depl_main}
\end{figure}

\end{document}
